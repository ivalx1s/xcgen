import Foundation
import ArgumentParser

struct PackageList: Decodable {
    var packages: [String: Remote]
}

struct PackageListPipeline: Decodable {
    var packages: [String: RemoteTracked]
}

struct Remote: Decodable, Hashable {
    let url: String?
    let version: String?
    let path: String?
    
    init(
        url: String? = nil,
        version: String? = nil,
        path: String? = nil
    ) {
        self.url = url
        self.version = version
        self.path = path
    }
}

struct RemoteTracked: Decodable {
    let url: String
    let version: String
    var checkoutAttempted: Bool
}

enum ParseError: Error {
    case cannotDecodePackageList
    case packageListHasntBeenDecoded
}

@main
struct XCGenCLI: ParsableCommand {
    
    static let configuration = CommandConfiguration(
        commandName: "xcgen",
        abstract: """
XCGen is a command-line utility that facilitates the initial setup of your xcodegen-powered projects.
It streamlines your workflow by interpreting the project manifest, extracting project dependencies,
and cloning these into the relevant directory alongside your main project.
This tool also ensures you're working with the right dependency versions by checking out the corresponding version tags.
""",
        subcommands: [
            FetchDependencies.self,
            Worktree.self,
            InstallHooks.self
        ]
    )
}

struct FetchDependencies: ParsableCommand {
    static let configuration = CommandConfiguration(
        commandName: "fetch",
        abstract: """
Fetch resolves and syncs all Swift package dependencies declared in your manifest (and their transitive dependencies).
""",
        discussion: """
ARGUMENTS:
  jsonFilePath         Path to the JSON manifest generated by xcgen plumbing or your own tooling.
  repositoryBasePath   Optional path for local clones. Defaults to ./.packages-<current-branch>.

OPTIONS:
  --dependency-graph-output <path>   Optional DOT file destination. Defaults to <repositoryBasePath>/dependency-graph.dot.
""",
        shouldDisplay: true
    )
    
    @Argument(help: ArgumentHelp(
        "Path to the json file containing information about packages.",
        discussion: "Relative paths are resolved from the current working directory."
    ))
    var jsonFilePath: String
    
    @Argument(help: ArgumentHelp(
        "Path where repositories should be cloned.",
        discussion: "Defaults to a branch-specific folder named ./.packages-<current-branch> when omitted."
    ))
    var repositoryBasePath: String = FetchDependencies.defaultRepositoryBasePath()
    
    @Option(name: .long, help: ArgumentHelp(
        "File path for the generated dependency graph (GraphViz DOT format).",
        discussion: "Defaults to <repositoryBasePath>/dependency-graph.dot."
    ))
    var dependencyGraphOutput: String?
    
    mutating func validate() throws {
        if jsonFilePath.lowercased() == "help",
           !FileManager.default.fileExists(atPath: jsonFilePath) {
            throw CleanExit.helpRequest(Self.self)
        }
    }
    
    func run() throws {
        let fileManager = FileManager.default
        let decoder = JSONDecoder()
        let currentDirectoryURL = fileManager.currentDirectoryPath
        let fileURL = URL(fileURLWithPath: currentDirectoryURL).appendingPathComponent(jsonFilePath)
        let projectNodeName = fileURL.deletingPathExtension().lastPathComponent
        let data = try Data(contentsOf: fileURL)
        
        let packageList: PackageList
        do {
            packageList = try decoder.decode(PackageList.self, from: data)
        } catch {
            throw ParseError.cannotDecodePackageList
        }
        
        var remotePackages: [String: Remote] = [:]
        var dependencyGraph: [String: Set<String>] = [:]
        func ensureNodeExists(_ name: String) {
            if dependencyGraph[name] == nil {
                dependencyGraph[name] = []
            }
        }
        func addEdge(from parent: String, to child: String) {
            ensureNodeExists(parent)
            ensureNodeExists(child)
            dependencyGraph[parent, default: []].insert(child)
        }
        ensureNodeExists(projectNodeName)
        var versionTracker = DependencyVersionTracker()
        func logConflict(for node: String) {
            guard let versions = versionTracker.requirements[node] else { return }
            let versionList = versions.keys.sorted().joined(separator: ", ")
            print("‚ö†Ô∏è Potential dependency conflict for \(node): versions [\(versionList)]")
        }
        for (_, remote) in packageList.packages {
            guard remote.path == nil,
                  let url = remote.url,
                  let version = remote.version else { continue }
            let repoName = repositoryName(from: url)
            ensureNodeExists(repoName)
            addEdge(from: projectNodeName, to: repoName)
            if versionTracker.record(version: version, for: repoName, source: projectNodeName) {
                logConflict(for: repoName)
            }
            if remotePackages[repoName] == nil {
                remotePackages[repoName] = Remote(url: url, version: version)
            }
        }
        
        let baseRepositoryURL: URL
        if repositoryBasePath.hasPrefix("/") {
            baseRepositoryURL = URL(fileURLWithPath: repositoryBasePath)
        } else {
            baseRepositoryURL = URL(fileURLWithPath: fileManager.currentDirectoryPath)
                .appendingPathComponent(repositoryBasePath)
        }
        let packagesDirPath = baseRepositoryURL.path
        try? fileManager.createDirectory(atPath: packagesDirPath,
                                         withIntermediateDirectories: true)
        let dependencyGraphOutputURL: URL
        if let dependencyGraphOutput, !dependencyGraphOutput.isEmpty {
            if dependencyGraphOutput.hasPrefix("/") {
                dependencyGraphOutputURL = URL(fileURLWithPath: dependencyGraphOutput)
            } else {
                dependencyGraphOutputURL = URL(fileURLWithPath: fileManager.currentDirectoryPath)
                    .appendingPathComponent(dependencyGraphOutput)
            }
        } else {
            dependencyGraphOutputURL = baseRepositoryURL.appendingPathComponent("dependency-graph.dot")
        }
        try? fileManager.createDirectory(atPath: dependencyGraphOutputURL.deletingLastPathComponent().path,
                                         withIntermediateDirectories: true)
        
        var checkedOutPackages: Set<String> = []
        
        while true {
            let worklist = remotePackages            // snapshot for safe iteration
            var newlyDiscovered: [String: Remote] = [:]  // collect inserts
            
            for (repoName, remote) in worklist {
                guard !checkedOutPackages.contains(repoName),
                      let url = remote.url,
                      let version = remote.version else { continue }
                
                print("\nüîÑ Processing package: \(repoName)")
                ensureNodeExists(repoName)
                
                let folderName = repositoryName(from: url)
                let repositorySupposedPath = baseRepositoryURL
                    .appendingPathComponent(folderName)
                    .path
                
                if !fileManager.fileExists(atPath: repositorySupposedPath) {
                    let cloneTask = Process()
                    cloneTask.launchPath = "/usr/bin/env"
                    cloneTask.arguments = [
                        "git",
                        "clone",
                        "--branch", version,
                        "--single-branch",
                        "--depth", "1",
                        "--no-tags",
                        url,
                        repositorySupposedPath
                    ]
                    cloneTask.standardOutput = FileHandle.nullDevice
                    cloneTask.standardError = FileHandle.nullDevice
                    cloneTask.launch()
                    cloneTask.waitUntilExit()
                    if cloneTask.terminationStatus != 0 {
                        print("‚ùóÔ∏è Failed to clone \(repoName) from \(url). Skipping further steps for this dependency.")
                        continue
                    }
                }
                guard fileManager.fileExists(atPath: repositorySupposedPath) else {
                    print("‚ùóÔ∏è Expected repository at \(repositorySupposedPath) but it is missing. Skipping \(repoName).")
                    continue
                }
                
                // Fetch task
                let fetchTask = Process()
                fetchTask.launchPath = "/usr/bin/env"
                fetchTask.arguments = [
                    "git",
                    "fetch",
                    "--depth", "1",
                    "--no-tags",
                    "origin",
                    "tag",
                    version
                ]
                fetchTask.currentDirectoryPath = repositorySupposedPath
                fetchTask.standardOutput = FileHandle.nullDevice
                fetchTask.standardError = FileHandle.nullDevice
                fetchTask.launch()
                fetchTask.waitUntilExit()
                
                if fetchTask.terminationStatus == 0 {
                    print("‚§µÔ∏è Successfully fetched latest changes from the repo")
                } else {
                    print("‚ùóÔ∏è Failed to fetch changes from \(url) for package \(repoName). Error \(fetchTask.terminationStatus). Up-to-date state of the repo cannot be guaranteed.")
                }
                
                // Checkout task
                let checkoutTask = Process()
                checkoutTask.launchPath = "/usr/bin/env"
                checkoutTask.arguments = ["git", "checkout", version]
                checkoutTask.currentDirectoryPath = repositorySupposedPath
                checkoutTask.standardOutput = FileHandle.nullDevice
                checkoutTask.standardError = FileHandle.nullDevice
                checkoutTask.launch()
                checkoutTask.waitUntilExit()
                
                if checkoutTask.terminationStatus == 0 {
                    print("#Ô∏è‚É£  Tag: \(version)")
                } else {
                    print("‚ùóÔ∏è Could not checkout \(repoName), tag \(version). Check version tag and try again.")
                }
                
                // Resolve task
                let packageResolveTask = Process()
                packageResolveTask.launchPath = "/usr/bin/env"
                packageResolveTask.arguments = ["swift", "package", "resolve"]
                packageResolveTask.currentDirectoryPath = repositorySupposedPath
                packageResolveTask.standardOutput = FileHandle.nullDevice
                packageResolveTask.standardError = FileHandle.nullDevice
                packageResolveTask.launch()
                packageResolveTask.waitUntilExit()
                
                checkedOutPackages.insert(repoName)
                
                let pinsURL = URL(fileURLWithPath: repositorySupposedPath)
                    .appendingPathComponent("Package.resolved")
                
                guard let pinsSerialized = try? Data(contentsOf: pinsURL) else { continue }
                
                print("üîÇ Extracting \(repoName) dependencies")
                
                let addDependency: (Dependency) -> Void = { dep in
                    let childRepoName = repositoryName(from: dep.url)
                    addEdge(from: repoName, to: childRepoName)
                    if versionTracker.record(version: dep.version, for: childRepoName, source: repoName) {
                        logConflict(for: childRepoName)
                    }
                    if remotePackages[childRepoName] == nil && newlyDiscovered[childRepoName] == nil {
                        newlyDiscovered[childRepoName] = Remote(url: dep.url, version: dep.version)
                    }
                }
                
                if let packagePins = try? decoder.decode(PackageResolved.WithoutObjRoot.Pins.self,
                                                         from: pinsSerialized) {
                    extractDependencies(from: packagePins).forEach(addDependency)
                } else if let packageObjs = try? decoder.decode(PackageResolved.WithObjRoot.Root.self,
                                                                from: pinsSerialized) {
                    extractDependencies(from: packageObjs).forEach(addDependency)
                } else {
                    print("‚ùóÔ∏è Could not deserialize Package.resolved, dependencies for \(repoName) have not been extracted")
                }
            }
            
            if newlyDiscovered.isEmpty {
                print("\n‚úÖ Finished")
                break
            }
            
            remotePackages.merge(newlyDiscovered) { existing, _ in existing }
        }
        try writeDependencyGraph(adjacencyList: dependencyGraph,
                                 nodeVersions: versionTracker.requirements,
                                 projectNodeName: projectNodeName,
                                 outputURL: dependencyGraphOutputURL)
        print("üß© Dependency graph saved to \(dependencyGraphOutputURL.path)")

        let conflicts = versionTracker.conflicts
        if !conflicts.isEmpty {
            print("\n‚ö†Ô∏è  Dependency conflicts detected:")
            conflicts.forEach { print($0.description) }
            throw CleanExit.message("Resolve dependency version conflicts before continuing.")
        }
    }
    
}


extension FetchDependencies {
    static func defaultRepositoryBasePath() -> String {
        let branchName = (try? Git.currentBranch()) ?? "HEAD"
        let directoryName = BranchNaming.packagesDirectoryName(for: branchName)
        return "./\(directoryName)"
    }
}


func writeDependencyGraph(adjacencyList: [String: Set<String>],
                          nodeVersions: [String: [String: Set<String>]],
                          projectNodeName: String,
                          outputURL: URL) throws {
    var dotRepresentation = "digraph Dependencies {\n"
    dotRepresentation.append("    rankdir=LR;\n")
    dotRepresentation.append("    node [shape=box];\n")
    var allNodes: Set<String> = Set(adjacencyList.keys)
    adjacencyList.values.forEach { allNodes.formUnion($0) }
    allNodes.insert(projectNodeName)
    for node in allNodes.sorted() {
        let versions = nodeVersions[node]
        let isConflict = (versions?.keys.count ?? 0) > 1
        let label = dependencyNodeLabel(for: node, versions: versions)
        let declaration = dotNodeDeclaration(node, label: label, isConflict: isConflict)
        dotRepresentation.append("    \(declaration)\n")
    }
    let sortedParents = adjacencyList.keys.sorted()
    for parent in sortedParents {
        let children = adjacencyList[parent] ?? []
        for child in children.sorted() {
            dotRepresentation.append("    \(dotEdge(from: parent, to: child))\n")
        }
    }
    dotRepresentation.append("}\n")
    try dotRepresentation.write(to: outputURL, atomically: true, encoding: .utf8)
}

func dependencyNodeLabel(for node: String,
                         versions: [String: Set<String>]?) -> String {
    guard let versions, !versions.isEmpty else { return node }
    if versions.keys.count == 1, let version = versions.keys.first {
        return "\(node) (\(version))"
    }
    let versionList = versions.keys.sorted().joined(separator: " vs ")
    return "\(node) (conflict: \(versionList))"
}

func dotEdge(from parent: String, to child: String) -> String {
    "\(dotIdentifier(parent)) -> \(dotIdentifier(child));"
}

func dotNodeDeclaration(_ value: String, label: String, isConflict: Bool) -> String {
    var attributes = ["label=\(dotLabel(label))"]
    if isConflict {
        attributes.append("color=\"#d14334\"")
        attributes.append("fontcolor=\"#d14334\"")
    }
    return "\(dotIdentifier(value)) [\(attributes.joined(separator: ", "))];"
}

func dotIdentifier(_ value: String) -> String {
    "\"\(value.replacingOccurrences(of: "\"", with: "\\\""))\""
}

func dotLabel(_ value: String) -> String {
    "\"\(value.replacingOccurrences(of: "\"", with: "\\\""))\""
}


func extractDependencies(from packageResolved: PackageResolved.WithoutObjRoot.Pins) -> [Dependency] {
    packageResolved.pins.map {
        // rethink approach, we have revisions in pins, which are more secure // üü°
        Dependency(name: $0.identity, url: $0.location, version: $0.state.version)
    }
}

func extractDependencies(from packageResolved: PackageResolved.WithObjRoot.Root) -> [Dependency] {
    packageResolved.object.pins.map {
        // rethink approach, we have revisions in pins, which are more secure // üü°
        Dependency(name: $0.package, url: $0.repositoryURL, version: $0.state.version)
    }
}

struct Dependency {
    var name: String
    var url: String
    var version: String
}



func repositoryName(from url: String) -> String {
    guard let lastComponent = url.split(separator: "/").last else { return url }
    return lastComponent.replacingOccurrences(of: ".git", with: "")
}


struct DependencyVersionTracker {
    private(set) var requirements: [String: [String: Set<String>]] = [:]
    
    @discardableResult
    mutating func record(version: String, for node: String, source: String) -> Bool {
        var nodeRequirements = requirements[node, default: [:]]
        let hadConflictBefore = nodeRequirements.keys.count > 1
        var sources = nodeRequirements[version, default: []]
        sources.insert(source)
        nodeRequirements[version] = sources
        requirements[node] = nodeRequirements
        let hasConflictAfter = nodeRequirements.keys.count > 1
        return !hadConflictBefore && hasConflictAfter
    }
    
    var conflicts: [DependencyConflict] {
        requirements
            .compactMap { key, versions in
                versions.keys.count > 1 ? DependencyConflict(node: key, versions: versions) : nil
            }
            .sorted { $0.node < $1.node }
    }
}

struct DependencyConflict: CustomStringConvertible {
    let node: String
    let versions: [String: Set<String>]
    
    var description: String {
        let versionDetails = versions
            .keys
            .sorted()
            .map { version in
                let sources = versions[version] ?? []
                let sortedSources = sources.sorted().joined(separator: ", ")
                return "  - \(version): \(sortedSources)"
            }
            .joined(separator: "\n")
        return "\(node):\n\(versionDetails)"
    }
}

extension String {
    func firstIndex(of substring: String) -> String.Index? {
        if let range = self.range(of: substring) {
            return range.lowerBound
        }
        return nil
    }
}
